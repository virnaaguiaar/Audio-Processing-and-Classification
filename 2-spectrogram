from google.colab import drive
drive.mount('/content/drive')
##
from IPython import get_ipython
from IPython.display import display
from scipy.signal import butter, filtfilt
##
!pip install tqdm
from tqdm import tqdm
##
!pip install opencv-python # Install the OpenCV library
import cv2 # Import the cv2 module
##
!pip install librosa
import librosa
##
# Filtro
def filtro_passa_banda(dado, fcorte_inf, fcorte_sup, famostrag, order=5):
  nyquist = 0.5 * famostrag #maior freq representada de forma precisa em um sinal digitalizado
  inf_normalz = fcorte_inf / nyquist #normalizar
  sup_normalz = fcorte_sup / nyquist
  b, a = butter(order, [inf_normalz, sup_normalz], btype='band')
     # coeficientes: b(numerador) a(denominador) para filtro de ordem 'order', que passa as freq entre 'inf_normalz' e 'sup_normalz'

  filtrar_dado = filtfilt(b, a, dado)
    # passa o filtro 2x (p frente e p trás) // evitar atraso de fase
  return filtrar_dado
##
import os
import numpy as np
import matplotlib.pyplot as plt

DATADIR = "/content/drive/MyDrive/audio2025/audios/gravados"
os.makedirs(DATADIR, exist_ok=True)
CATEGORIES = ["left", "right"]
dado=[]
espectrograma_dir = "/content/drive/MyDrive/audio2025/audios/espectrogramas"
os.makedirs(espectrograma_dir, exist_ok=True)

for category in CATEGORIES:
  #cria o caminho
  category_dir = os.path.join(espectrograma_dir, category)

  #cria o diretório se não existir
  os.makedirs(category_dir, exist_ok=True)

  path = os.path.join(DATADIR, category)

  #divide as classes de cada comando
  label = CATEGORIES.index(category)

  #retrona lista dos arquivos de 'path' // tqdm = barra de progresso // desc = descrição // unit = unidade mostrada na barra de progesso
  for audio_file in tqdm(os.listdir(path), desc=f'Carregando áudios de {category}', unit='áudio'):
    #caminho absoluto do áudio (diretório+nome do arquivo)
    audio_path = os.path.join(path, audio_file)

    # y_1: amostras do sinal de áudio, cada valor é a 'amplitude' em um ponto no tempo
    #taxa de amostragem (amostras por segundo)
    y_1, sr_1 = librosa.load(audio_path)

    # Permitir frequências entre 100 Hz e 10.000 Hz passarem // order = "agudeza" da filtragem
    y_1_f = filtro_passa_banda(y_1, 100, 10000, sr_1, order=5)

    # Trimms
    # Remover silêncios do início e do fim do áudio (<20db = silêncio)
    y_1_f_trimmed, _ = librosa.effects.trim(y_1_f, top_db = 20)

    # Transformada de Fourier de Curto Tempo (divide o áudio e calcula o espectro de freq de cada segmento)
    amp_y_1 = librosa.stft(y_1_f_trimmed)
    #Converte a amplitude do espectro para decibéis (dB)(uma escala logarítmica)
    y_1_db = librosa.amplitude_to_db(np.abs(amp_y_1), ref=np.max) #(espectrograma do áudio convertido para dB)


    # Ver s y_1_db tem valor válido
    if y_1_db is not None:
      # cria caminho de acordo com a categoria e nomeia em png
      espectrograma_path = os.path.join(category_dir, f"{os.path.splitext(audio_file)[0]}.png")

      # figura, eixo = gráfico no matplotlob com 5x3 polegadas
      fig_1, ax_1 = plt.subplots(figsize=(5, 3))
      # retira os eixos
      plt.axis('off')
      # função que exibe o espectorama y_1_db//x=tempo, y=amplitude
      librosa.display.specshow(y_1_db, x_axis='time', y_axis='log', ax=ax_1)
      # salvar a imagem = em tela cheia, sem espaços brancos ao redor
      plt.savefig(espectrograma_path, bbox_inches='tight', pad_inches=0)
      # fechar o gráfico para liberar memória (e evitar interferências)
      plt.close()
      # Carregar a imagem com OpenCV ( leitra para ser manipulado como um array numérico - processamentos futuros)
      image = cv2.imread(str(espectrograma_path))
      # Espectrograma e o rótulo (label) são adicionados à lista dado
      dado.append([image, label])

##
espectrogramas = []
labels = []
for spec, lab in dado:
  spec_shape = spec.shape
  espectrogramas.append(spec)
  labels.append(lab)

labels = np.array(labels)
